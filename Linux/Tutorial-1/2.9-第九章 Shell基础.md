# 第九章 Shell基础
[视频地址：第九章 Shell基础](http://www.imooc.com/video/4524)

---
## 9-1 shell概述
- Shell是一个命令解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell开启动，挂起，停止甚至是编写一些程序

- Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性强。Shell是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令

- Shell的分类：
>Bourne Shell: sh,ksh,Bash,psh
>C Shell: csh,tsch
>Linux的标准shell叫Bash

- Bash: Bash与sh兼容，现在使用的Linux就是使用Bash作为用户的基本Shell

---
## 9-2 脚本执行方式

**1. echo输出命令**
```
echo 【选项】【输出内容】

选项：
-e: 支持反斜线控制的字符转换
```

**控制字符**

|  控制字符 |  作用 |
| ------------ | ------------ |
| \a  |  输出警告音 |
| \b  | 退格键，就是向左删除键  |
| \n | 换行符 |
| \r  | 回车键  |
| \t |  制表符，也就是Tab键 |
| \v |  垂直制表符 |
| \0nnn  | 按照八进制ASCII码表输出字符，其中0代表数字零，nnnn是三位八进制数  |
| \xhh  | 按照十六进制ASCII码表输出字符 ，其中hh是两位十六进制数 |

**输出颜色**
```
echo -e "\e[1;31m 此处是输出内容 \e[0m"

其中：
1：表示开启颜色
31m:表示颜色值，这里是红色

更多颜色：
30m=黑色
31m=红色
32m=绿色
33m=黄色
34m=蓝色
35m=洋红
36m=青色
37m=白色
```


**举例：**
```
# 1. 输出字符串
echo "hello world"
hello world

# 2. 加入控制字符：换行符
echo -e "hello \nworld"
hello 
world

# 3. 控制字符：制表符
echo -e "h\te\tl\tl\to"
h    e    l    l    o

# 4. 按照十六进制ASCII码输出
echo -e "\x68\t\x65\t\x6c\n\x6c\t\x6f"
h    e    l
l    o
# 十六进制表示方法：\x
# 十六进制转化： 68=>h,65=>e,6c=>l,6f=>o

# 5. 输出内容带颜色值
echo -e "\e[1;31m this line will be turn red \e[0m"
this line will be turn red   #在xshell界面显示是红色的

```
>1. Linux本地字符化界面不能识别中文，但是远端登陆比如xshell和图形化可以通过设置识别中文

**2. 第一个脚本**
```
vi hello.sh
#!/bin/bash
# the first program

echo "\e[1;32m hello world \e[0;0m"

```
>1. \#号代表注释，但是 #!/bin/bash 这个不是注释，是申明这是个linux的标准脚本
>2. 不写#!/bin/bash也可以执行一些简单的shell脚本，但是一旦涉及其他语言，不申明的话会出错，所以还是要写这句话


**3. 脚本执行**
```
# 1. 赋予执行权限，直接运行
chmod 755 hello.sh
./hello.sh

# 2. 通过Bash调用执行脚本
bash hello.sh
```

**vi 操作**
```
vi test.sh //打开test.sh
i          //代表insert,插入

ESC键
：wq       //先按ESC键，然后：wq，代表保存并且退出，直接退出时：q
```

---
## 9-3 别名与快捷键（Bash的基本功能）

**1. 命令别名与快捷键**

查看与设定别名
```
alias
#查看系统中所有的命令别名

alias 别名= '原命令'
设定命令别名
```
举例1：
```
alias

alias cp='cp -i'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias ls='ls --color=auto'
alias mv='mv -i'
alias rm='rm -i'
alias vi='vim'
# 以上是系统中已设定的命令别名
```
举例2：
```
# vi 打开文件的时候没有颜色支持（vim 有颜色支持，功能比vi强大）

alias vi='vim'  
# 将vi 设定为命令vim的别名，这样执行vi的时候就相当于执行vim
```
别名永久生效与删除别名
```
vi ~/.bashrc
# 写入环境变量配置文件
# 环境变量文件不止这一个，root用户在root目录下，普通用户在home目录下

vi /root/.bashrc  #打开这个放置别名变量的环境变量文件
alias vi='vim'    #插入这句话

source /root/.bashrc  #使配置文件生效
```

删除别名
```
unalias 别名
# 删除别名
# 彻底删除需要在.bashrc中删除别名的设定
```

命令的生效顺序
```
1.第一顺位执行用绝对路径或相对路径执行的命令
2.第二顺位执行别名
3.第三顺位执行Bash的内部命令
4.第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令
```

常用快捷键
```
Ctrl+c  强制终止当前命令
Ctrl+l  清屏
Ctrl+a  光标移动到命令行首
Ctrl+e  光标移动到命令行尾
Ctrl+u  删除光标之前的到行首的整行
Ctrl+z  把命令放到后台
Ctrl+r  在历史命令中搜索
```


---
## 9-4 历史命令

**1. 历史命令： history**
```
history [选项] [历史命令保存文件]
选项：
-c:清空历史命令
-w ：把缓存中的历史命令写入历史命令保存文件~/.bash_history
```
>1. 历史命令保存在用户家目录下的.bash_history文件，每个用户都会有自己的历史命令保存文件
>2. 通过history查看的命令一般要比在.bash_history中多，因为文件中保存的是上一次正确退出前历史命令，这次登录操作的命令还没有保存进去，执行 hisroy -w 可以将这次操作的命令写入文件
>3. 历史命令默认保存1000条，若要修改可到/etc/profile里面查找HISTSIZE修改值就可以了

**2. 历史命令的调用**
```
1- 使用上下箭头调用以前的历史记录
2-！n重复执行第n条命令
3-！！重复执行上一条命令
4-"！字串"重复执行最后一条包括此字串的命令
```


**3. 命令与文件补全**
```
命令补全依赖环境变量，
文件补全依赖查询路径，
Tab键作用：
1-加快查找速度
2-避免查询出错
```

---
## 9-5 输出重定向

**1. 标准输入输出**

| 设备  | 设备文件名  | 文件描述符  |  类型 |
| ------------ | ------------ | ------------ | ------------ |
| 键盘 |  /dev/stdin | 0 |  标准输入 |
|  显示器 |  /dev/sdtout | 1  |  标准输出 |
|  显示器 |  /dev/sdterr | 2  | 标准错误输出  |

**2. 输出重定向**

| 类型  |  符号 | 作用  |
| ------------ | ------------ | ------------ |
| 标准输出重定向  |  命令 > 文件 | 以覆盖的方式，把命令的正确输出输出到指定的文件或者设备中  |
| 标准输出重定向  | 命令 >> 文件  | 以追加的方式，把命令的正确输出输出到指定的文件或者设备中  |
| 标准错误输出重定向  |  错误命令 2>文件 |  以覆盖的方式，把命令的错误输出输出到指定的文件或者设备中 |
| 标准错误输出重定向   | 错误命令 2>>文件  |  以追加的方式，把命令的错误输出输出到指定的文件或者设备中 |
>1. 输出重定向就是把本来应该输出到屏幕的内容保存到了文件中
>2. 注意，正确输出,>符号和文件之间有空格；错误输出，>符号和文件之间没空格


举例1：
```
ifcongif > test.log #把ifconfig要显示的内容写入了test.log文件中

cat test.log #打开这个文件可以看到ifconfig显示的内容

ls > test.log # ls显示的结果会覆盖之前的，因为单个>是覆盖操作

ls >> test.log ##双>>是追加内容
```
>这种标准输出只能记录正确命令的输出，要记录错误的输出在>前加个2

举例2：
```
suibianda 2>test.log # suibianda是错误命令

cat test.log  #此时打开test.log可以看到报错信息
-bash: fdfdfdf: command not found
```
>注意：错误输出>符号和文件名之间不能有空格

**3. 正确输出和错误输出同时保存**

| 方式  | 解释  |
| ------------ | ------------ |
|  命令 > 文件 2>&1 |  以覆盖的方式，把正确输出和错误的输出都保存到指定的文件当中  |
|  命令 >> 文件 2>&1 |  以追加的方式，把正确输出和错误的输出都保存到指定的文件当中  |
|  命令 &>文件 | 以覆盖的方式，把正确输出和错误的输出都保存到指定的文件当中  |
|  命令 &>>文件  |  以追加的方式，把正确输出和错误的输出都保存到指定的文件当中 |
|  命令>>文件1 2>>文件2 |  把正确的输出追加到文件1，把错误的输出追加到文件2 |
>2,4,5是常见操作

解释：
```
命令 >> 文件 2>&1 
#如果命令正确则直接写入文件
#如果命令错误，则将错误的结果写入正确的结果中，然后连同正确的同时写入文件
```

举例1：
```
ls &>>test.log  #将执行结果追加到test3.log
ls bucunzai &>>test3.log # ls一个不存在的目录，将执行结果追加

cat test3.log
# 结果显示如下
abc
abc.zip
default
haha
hahatest
haha.zip
pifupai
shell
test2.log
test.log
ls: cannot access bucunzai: No such file or directory
```

举例2：
```
ls &>/dev/null
#/dev/null 是linux中的黑洞目录，相当于垃圾站
#这条命令的作用是可以将不想看到的执行结果直接丢到垃圾站中
```

**4. 输入重定向**
```
wc 【选项】【文件名】

选项：
-c: 统计字节数
-w: 统计单词数
-l: 统计行数

wc < 文件  #可以统计这个文件的字节单词行数
wc 文件    #同 wc > 文件
wc << 标识符  #统计标识符和标识符之间的数据
```

---
## 9-6 管道符

**1. 多命令顺序执行**

|  多命令执行符 |  格式 | 作用  |
| ------------ | ------------ | ------------ |
|  ; |  命令1 ; 命令2 |  多个命令顺序执行，命令间没有任何逻辑关系 |
| &&  | 命令1 && 命令2  |  命令1执行正确，命令2才会执行；命令1执行错误u，命令2不执行 |
| 或符号  | 命令1 或符号 命令2  | 命令1执行正确，命令2不会执行；命令1执行错误u，命令2执行  |

>最后一个用中文代替是，||和制表符冲突了，所以用中文代替

举例1：
```
date ; tar -zcvf test.tar.gz ; date
# 先打印一下系统时间，然后执行打包命令，最后打印一下时间
# 以上可以根据前后时间计算出打包用的时长
```

举例2：
```
ls && echo yes  #可以执行
ls bucunzai && echo yes #第一个命令报错，第二个不执行
```


**2. 管道符**
```
命令1 | 命令2

命令1的正确输出作为命令2的操作对象

```
举例：
```
more 命令可以分屏查看文件内容
more 文件

ls -l /etc | more
# more能分屏查看前面输入的内容

netstat -an | grep ESTABLISHED | wc -l
# netstat -an:参看系统当中所有网络连接，ESTABLISHED表示有人正在使用端口
# grep ESTABLISHED： 查询文件当中的包含ESTABLISHED字符串的行
# wc -l ：统计有多少行
#整条命令意思是有多少个客户端连接
```

---
## 9-7 通配符

**1. 通配符**

|  通配符 | 作用  |
| ------------ | ------------ |
| ?  | 匹配任意一个字符  |
| *  |  匹配0个或任意多个字符 |
| []  | 匹配括号中的任意一个字符 ，比如[abc]匹配一个a或者b或者c |
| [-]  |  匹配括号中的任意一个字符，-代表一个范围。如果想匹配多个，可以多个[]并排，比如[a-z]匹配小写字母 |
| [^]  |  逻辑非，表示不是匹配括号内的一个字符，比如[^0-9]匹配一个不是数字的字符 |

举例：
```
环境：tes  test  test2  test3  testgggg

ls test
test

ls te*
tes  test  test2  test3  testgggg

ls test[0-9]
test2 test3

ls test[^0-9]*
testgggg
```

**2. Bash中其他特殊符号**

```
'':  单引号,输出字符串
"":  双引号，除了$, `, "", 特殊字符，其他按正常的输出
``:  反引号，反引号括起来的内容是系统命令，在Bash先执行它。和$()作用一样，不过推荐使用$(),因为反引号容易看错
$(): 和反引号作用一样，用来引用系统命令
#：  在shell脚本中，#号开头意味着注释
$:   用于调用变量的值，如需要调用name的值时，需要用$name的方式得到变量 
\:   转义符
```

反引号与$()
```
aa=`ls`   #将命令ls的结果赋给aa
echo $aa  #打印aa的值

aa=$(ls)  # 同上，但是这样方式更加直观，因为反引号容易看错
echo $aa
```

举例：
```
aa=123
echo $aa     #输出 123
echo '$aa'   #输出 $aa
echo "$aa"   #输出 123
```
