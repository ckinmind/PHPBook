### 第13节 正则表达式基础
[教程地址： 第13节 正则表达式基础](https://www.shiyanlou.com/courses/1/labs/354/document)

---

### 实验介绍
>虽然我们这一节的标题是正则表达式，但实际这一节实验只是介绍grep，sed，awk这三个命令，而正则表达式作为这三个命令的一种使用方式（命令输出中可以包含正则表达式）

### 一、正则表达式
- 简单的说形式和功能上正则表达式和我们前面讲的通配符很像，不过它们之间又有很大差别，特别在于一些特殊的匹配字符的含义上，希望初学者注意不要将两者弄混淆

#### 1. 举例
- 正则中的`*` 和通配符的`*`的含义有很大的区别

####  2.基本语法：
>一个正则表达式通常被称为一个模式（pattern），为用来描述或者匹配一系列符合某个句法规则的字符串

-  **选择：** `|` 竖直分隔符表示选择，例如"boy|girl"可以匹配"boy"或者"girl"

- **数量限定：** 数量限定除了我们举例用的`*`,还有`+`加号,`?`问号,`.`点号，如果在一个模式中不加数量限定符则表示出现一次且仅出现一次
   - `+`表示前面的字符必须出现至少一次(1次或多次)，例如，"goo+gle",可以匹配"gooogle","goooogle"等；
   - `?`表示前面的字符最多出现一次(0次或1次)，例如，"colou?r",可以匹配"color"或者"colour";
   - `*`星号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次），例如，“0*42”可以匹配42、042、0042、00042等。

- **范围和优先级 : **`()`圆括号可以用来定义模式字符串的范围和优先级，这可以简单的理解为是否将括号内的模式串作为一个整体。例如，"gr(a|e)y"等价于"gray|grey"，（这里体现了优先级，竖直分隔符用于选择a或者e而不是gra和ey），"(grand)`?`father"匹配father和grandfather（这里体验了范围，?将圆括号内容作为一个整体匹配）

**语法（部分）**
>正则表达式有多种不同的风格，下面列举一些常用的作为 PCRE 子集的适用于perl和python编程语言及grep或egrep的正则表达式匹配规则：(由于markdown表格解析的问题，下面的竖直分隔符用全角字符代替，实际使用时请换回半角字符)

|字符|描述|
|-----|-----|
|\|将下一个字符标记为一个特殊字符、或一个原义字符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。序列“\\”匹配“\”而“\(”则匹配“(”。|
|^|匹配输入字符串的开始位置。|
|$|匹配输入字符串的结束位置。|
|{n}|n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。|
|{n,}|n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。|
|{n,m}|m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。|
|*|匹配前面的子表达式零次或多次。例如，zo*能匹配“z”、“zo”以及“zoo”。*等价于{0,}。|
|+|匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。|
|?|匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。|
|?|当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。|
|.|匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.｜\n)”的模式。|
|(pattern)|匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。要匹配圆括号字符，请使用“\(”或“\)”。|
|x｜y|匹配x或y。例如，“z｜food”能匹配“z”或“food”。“(z｜f)ood”则匹配“zood”或“food”。|
|[xyz]|字符集合（character class）。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。其中特殊字符仅有反斜线\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果如果出现在首位则仅作为普通字符。|
|[^xyz]|排除型（negate）字符集合。匹配未列出的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。|
|[a-z]|字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。|
|[^a-z]|排除型的字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。|


**优先级**
>优先级为从上到下从左到右，依次降低：

|运算符|说明|
|-----|-----|
|\|转义符|
|(), (?:), (?=), []|括号和中括号|
|*、+、?、{n}、{n,}、{n,m}|限定符|
|^、$、\任何元字符|定位点和序列 |
|｜|　选择|

**regex的思导图：**

![](https://dn-anything-about-doc.qbox.me/linux_base/RegularExpression.png)

---
### 二、grep模式匹配命令

#### 1.基本操作
```
grep命令用于打印输出文本中匹配的模式串，它使用正则表达式作为模式匹配的条件。grep支持三种正则表达式引擎，分别用三个参数指定：
-E    POSIX扩展正则表达式，ERE
-G    POSIX基本正则表达式，BRE
-P    Perl正则表达式，PCRE

不过在你没学过perl语言的大多数情况下你将只会使用到ERE和BRE,所以我们接下来的内容都不会讨论到PCRE中特有的一些正则表达式语法（它们之间大部分内容是存在交集的，所以你不用担心会遗漏多少重要内容）
```

在通过grep命令使用正则表达式之前，先介绍一下它的常用参数：
```
-b    将二进制文件作为文本来进行匹配
-c    统计以模式匹配的数目
-i    忽略大小写
-n    显示匹配文本所在行的行号
-v    反选，输出不匹配行的内容
-r    递归匹配查找
-A n    n为正整数，表示after的意思，除了列出匹配行之外，还列出后面的n行
-B n    n为正整数，表示before的意思，除了列出匹配行之外，还列出前面的n行
--color=auto    将输出中的匹配项设置为自动颜色显示
```
![](https://dn-anything-about-doc.qbox.me/linux_base/11-2.png)


#### 2.使用正则表达式
使用基本正则表达式，BRE
```
# grep默认是区分大小写的，这里将匹配所有的小写字母
$ echo '1234\nabcd' | grep '[a-z]'
# 将匹配所有的数字
$ echo '1234\nabcd' | grep '[0-9]'
# 将匹配所有的数字
$ echo '1234\nabcd' | grep '[[:digit:]]'
```
下面包含完整的特殊符号及说明:

|特殊符号|说明|
|-----|-----|
|[:alnum:]|代表英文大小写字节及数字，亦即 0-9, A-Z, a-z|
|[:alpha:]|代表任何英文大小写字节，亦即 A-Z, a-z|
|[:blank:]|代表空白键与 [Tab] 按键两者|
|[:cntrl:]|代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等|
|[:digit:]|代表数字而已，亦即 0-9|
|[:graph:]|除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键|
|[:lower:]|代表小写字节，亦即 a-z|
|[:print:]|代表任何可以被列印出来的字节|
|[:punct:]|代表标点符号 (punctuation symbol)，亦即：" ' ? ! ; : # $...|
|[:upper:]|代表大写字节，亦即 A-Z|
|[:space:]|任何会产生空白的字节，包括空白键, [Tab], CR 等等|
|[:xdigit:]|代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节|
>注意：之所以要使用特殊符号，是因为上面的[a-z]不是在所有情况下都管用，这还与主机当前的语系有关，即设置在LANG环境变量的值，zh_CN.UTF-8的话[a-z]，即为所有小写字母，其它语系可能是大小写交替的如，"a A b B...z Z"，[a-z]中就可能包含大写字母。所以在使用[a-z]时请确保当前语系的影响，使用[:lower:]则不会有这个问题

```
# 排除字符
$ echo 'geek|good' | grep '[^o]'
```
>注意:当^放到中括号内为排除字符，否则表示行首。

**使用扩展正则表达式，ERE**
>略


---
### 三、sed 流编辑器

- sed工具在 man 手册里面的全名为"sed - stream editor for filtering and transforming text "，意即，用于过滤和转换文本的流编辑器
- sed是一个非交互式的编辑器

#### sed常用参数介绍
```
# sed 命令基本格式：
sed [参数]... [执行命令] [输入文件]...
# 形如：
$ sed -i '1s/sad/happy/' test # 表示将test文件中第一行的"sad"替换为"happy"

===========================================
参数：
-n    安静模式，只打印受影响的行，默认打印输入数据的全部内容
-e    用于在脚本中添加多个执行命令一次执行，在命令行中执行多个命令通常不需要加该参数
-f filename    指定执行filename文件中的命令
-r    使用扩展正则表达式，默认为标准正则表达式
-i    将直接修改输入文件内容，而不是打印到标准输出设备

====================================================
sed执行命令格式：
[n1][,n2]command
[n1][~step]command
# 其中一些命令可以在后面加上作用范围，形如：
$ sed -i 's/sad/happy/g' test # g表示全局范围
$ sed -i 's/sad/happy/4' test # 4表示指定行中的第四个匹配字符串

其中n1,n2表示输入内容的行号，它们之间为,逗号则表示从n1到n2行，如果为～波浪号则表示从n1开始以step为步进的所有行；command为执行动作，下面为一些常用动作指令：

s    行内替换
c    整行替换
a    插入到指定行的后面
i    插入到指定行的前面
p    打印指定行，通常与-n参数配合使用
d    删除指定行
```

**备注：命令练习查看教程**

---

### 四、awk文本处理语言

#### 1.awk介绍
- AWK是一种优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一
- 它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能，AWK是一种用于处理文本的编程语言工具

#### 2.awk的一些基础概念
- awk所有的操作都是基于pattern(模式)—action(动作)对来完成的，如下面的形式：`$ pattern {action}`
   -  其中pattern通常是是表示用于匹配输入的文本的“关系式”或“正则表达式”
   - action则是表示匹配后将执行的动作
   - 在一个完整awk操作中，这两者可以只有其中一个，如果没有pattern则默认匹配输入的全部文本，如果没有action则默认为打印匹配内容到屏幕
   
#### 3.awk命令基本格式
```
awk [-F fs] [-v var=value] [-f prog-file | 'program text'] [file...]
```

#### 4.awk操作体验
>参看教程

---
作业：[vim大冒险](http://vim-adventures.com/)
>一个在线游戏，学习vim操作
